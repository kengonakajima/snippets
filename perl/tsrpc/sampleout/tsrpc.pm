#
# generated by tsrpcgen 
#
# please don't edit this file.
#
#
#


package tsrpc;

require 5.000;
use Exporter;
use IO::Socket;
use IO::Select;

##########################
#
# このファイルは変更してはならないが、デバッグのために以下の項目を
# 変更することが可能。
#
# $verbose = 0/1   デバッグverboseモードの設定。
##########################
my $verbose = 1;
my $max_udp_size = 8800;   # RPCSRC40のコードからぬすんだ


##########################
# client code 
#
#
# Keep_aliveの実現方法
# ( $sock, @args )
##########################
sub call_tsrpctcp($@)
{
# arguement part  
	my $sock = shift;
	my $str = join( ' ' , @_ );

	print "data: $str\n";
# main part
	print $sock "$str\n";
	$sock->flush();
	my $ret = <$sock>;
	chomp( $ret );

	print "retdata: $ret\n";
# return part
	return $ret;
}

sub call_tsrpcudp($@)
{
# arguemen part
	my $sock = shift;
	my $str = join( ' ' , @_ );
	
	print "data: $str\n";

#main part
	$sock->send( $str );
	return "call_tsrpcudp:no_answer.";	
}


#
# common part of client and server programs
#
#







sub escape($)
{
	$_ = shift;

	s/ /\\S/g;
	s/\n/\\n/g;

	return $_;
}

sub descape($)
{
	$_ = shift;

	s/\\n/\n/g;
	s/\\S/ /g;

	return $_;
}



# 入力はperlの生なスカラで、出力はエスケープされたネットワーク文字列表現。
sub mkstr_long32($){ return unpack( "l" , pack("l",shift()));  }
sub mkstr_u_long32($){	return unpack( "L" , pack("L",shift()));  }
sub mkstr_int32($){	return unpack( "i" , pack("i" , shift()));  }
sub mkstr_u_int32($){	return unpack( "I" , pack("I" , shift()));  }
sub mkstr_short16($){	return unpack( "s" , pack("s" , shift()));  }
sub mkstr_u_short16($){	return unpack( "S" , pack("S" , shift()));  }
sub mkstr_char8($){	return unpack( "c" , pack("c" , shift()));  }
sub mkstr_u_char8($){	return unpack( "C" , pack("C" , shift()));  }
sub mkstr_float32($){	return unpack( "f" , pack("f" , shift()));  }
sub mkstr_double64($){	return unpack( "d" , pack("d" , shift()));  }
sub mkstr_string($){ return escape( shift()); }
sub mkstr_long32_array(@){ return mkstr_array_base(  \&mkstr_long32 , 0 , @_ ); }
sub mkstr_u_long32_array(@){ return mkstr_array_base( \&mkstr_u_long32 , 0 ,@_ ); }
sub mkstr_int32_array(@){ return mkstr_array_base( \&mkstr_int32 , 0 , @_ ); }
sub mkstr_u_int32_array(@){ return mkstr_array_base( \&mkstr_u_int32 , 0 ,@_ ); }
sub mkstr_short16_array(@){ return mkstr_array_base( \&mkstr_short16 , 0 , @_ ); }
sub mkstr_u_short16_array(@){ return mkstr_array_base( \&mkstr_u_short16 , 0 ,@_ ); }
sub mkstr_char8_array(@){ return mkstr_array_base( \&mkstr_char8 , 0 , @_ ); }
sub mkstr_u_char8_array(@){ return mkstr_array_base( \&mkstr_u_char8 , 0 ,@_ ); }
sub mkstr_float32_array(@){ return mkstr_array_base( \&mkstr_float32 , 0 , @_ ); }
sub mkstr_double64_array(@){ return mkstr_array_base( \&mkstr_double64 , 0  , @_ ); }
sub mkstr_string_array(@){ return mkstr_array_base( \&mkstr_string , 0 , @_ ); }
# 配列を作る場合の基本関数
# ( \&func , $defaultvalue , @_ )
sub mkstr_array_base($$@)
{
		my $func = shift;
		my $defaultvalue = shift;
		my $size = @_;	

		my @out;
		for( $i=0;$i<$size;$i++){
			push( @out,  &$func( $_[$i] ) );
		}
		return join( ' ', @out );
}


# 入力は、ネットワーク表現で、出力はperlの生なデータ。
sub demkstr_long32($){ return unpack( "l" , pack( "l" , shift())); }
sub demkstr_u_long32($){ return unpack( "L" , pack("L",shift()));  }
sub demkstr_int32($){ return unpack( "i" , pack("i" , shift()));  }
sub demkstr_u_int32($){	return unpack( "I" , pack("I" , shift()));  }
sub demkstr_short16($){	return unpack( "s" , pack("s" , shift()));  }
sub demkstr_u_short16($){ return unpack( "S" , pack("S" , shift()));  }
sub demkstr_char8($){	return unpack( "c" , pack("c" , shift()));  }
sub demkstr_u_char8($){	return unpack( "C" , pack("C" , shift()));  }
sub demkstr_float32($){	return unpack( "f" , pack("f" , shift()));  }
sub demkstr_double64($){ return unpack( "d" , pack("d" , shift()));  }
sub demkstr_string($){ return descape( shift()); }
sub demkstr_long32_array(@){ return demkstr_array_base( \&demkstr_long32 ,@_ ); }
sub demkstr_u_long32_array(@){ return demkstr_array_base( \&demkstr_u_long32 ,@_ ); }
sub demkstr_int32_array(@){ return demkstr_array_base( \&demkstr_int32 ,@_ ); }
sub demkstr_u_int32_array(@){ return demkstr_array_base( \&demkstr_u_int32 ,@_ ); }
sub demkstr_short16_array(@){ return demkstr_array_base( \&demkstr_short16 ,@_ ); }
sub demkstr_u_short16_array(@){ return demkstr_array_base( \&demkstr_u_short16 ,@_ ); }
sub demkstr_char8_array(@){ return demkstr_array_base( \&demkstr_char8 ,@_ ); }
sub demkstr_u_char8_array(@){ return demkstr_array_base( \&demkstr_u_char8 ,@_ ); }
sub demkstr_float32_array(@){ return demkstr_array_base( \&demkstr_float32 ,@_ ); }
sub demkstr_double64_array(@){ return demkstr_array_base( \&demkstr_double64 ,@_ );}
sub demkstr_string_array(@){ return demkstr_array_base( \&demkstr_string ,@_ ); }

# 配列のデコードは、リストの項目を処理するだけ
# 引数の配列のサイズは上のルーチンによって正しくなっているとする
sub demkstr_array_base($@)
{
	my $func = shift;
	my @out;
	my $a;
	for $a ( @_ ){
		push (@out , &$func($a) );
	}
	return @out;
}
#
# 引数のさいずを強制する
#
sub fillargs($@)
{
	my $dest = shift;
	my $siz = @_;
	my $i;

	print "SRC: $siz , DEST: $dest \n";
	
# サイズがちがう
	if( $dest < $siz ){
		print "made small!!\n";
		return splice( @_ , 0 , $siz );
	} elsif( $dest > $siz ){
		print "made big!!\n";
		for( $i = $siz ; $i < $dest ; $i++ ){
			push( @_ , "0" );
		}
		return @_;
	} else {
		return @_;
	}
}
##########################
#
# 以下はTSRPCに関係ないルーチン集
#
#
##########################
#
# verbose print: 
# printv( string)   $verboseが真だったら表示する
sub printv($)
{
	if( $verbose ){	print shift;  }

}

1;




