# SQLCipher + FTS5 ベンチマークサンプル

SQLCipher を組み込んだ SQLite データベースで全文検索(FTS5)を行い、暗号化あり/なしの検索性能を比較する Node.js サンプルです。10,000 件のランダムな文章を投入し、同じキーワードで全文検索を 10 回ずつ実行して平均時間を算出します。

## 動作環境

- Node.js 16.13.0
- npm 8.1.4
- SQLCipher 3.46.1 (`sqlcipher` コマンドが利用可能であること)

## セットアップ

```bash
npm install
```

## ベンチマークの実行

```bash
npm run benchmark
```

実行すると `data/plain.db` (平文) と `data/encrypted.db` (暗号化) を再生成し、全文検索を計測します。暗号化側のパスフレーズは `passing-sample-key` に固定しています。

## 計測結果 (2025-09-17 実行)

| 区分 | 平均 (ms) | 最小 (ms) | 最大 (ms) | 備考 |
| ---- | --------: | --------: | --------: | ---- |
| 暗号化なし | 11.281 | 10.765 | 11.911 | 10 回測定の平均 |
| 暗号化あり | 11.743 | 10.695 | 15.796 | 10 回測定の平均 |

- 平均差分: **+0.461 ms (約 +4.1%)** で暗号化ありの方がわずかに遅い結果でした。
- ランダムデータ生成と検索キーワード(`cipherword`)はスクリプト内で固定されています。
- 暗号化 DB は `sqlite3 data/encrypted.db` では開けず ("file is not a database"), `sqlcipher` でキーフレーズを設定することで読み出せることを確認済みです。

## 実装のポイント

- `@journeyapps/sqlcipher` を利用し、Node.js から直接 SQLCipher を扱っています。
- データ投入はトランザクション内でバルク INSERT を発行し、FTS5 仮想テーブルを利用しています。
- 計測は `performance.now()` で計測した掛かった時間を配列に記録し、平均/最小/最大を算出しています。

## 補足

- 測定はシングルスレッドで実行しているため、CPU 負荷や I/O 状況により結果は変動します。必要に応じて繰り返し回数やデータ件数を変更して再測定してください。
- パスフレーズなどの機密情報を変更して利用する場合は、アプリケーションコードから分離して安全に管理してください。
